# Папка 01: Работа с файлами и предсказание настроения

## Задача 1: Фильтр файлов (01/file_filter.py)

### Описание
Модуль `file_filter.py` предоставляет функции для фильтрации текстовых данных из файлов и строк.

### Функции

1. **gen(f_obj, lst)**
   - Генератор, фильтрующий строки файла по списку слов.
   - Принимает файловый объект `f_obj` и список слов `lst`.
   - Возвращает строки файла, содержащие хотя бы одно слово из списка.
   - Автоматически закрывает файл после завершения.

2. **from_str_to_file_obj(st)**
   - Конвертирует строку `st` в файловый объект.

### Тестирование (test_file_filter.py)
Модуль `test_file_filter.py` содержит юнит-тесты для функции `gen` в файле `file_filter.py`.

## Задача 2: Предсказание настроения (01/predicator.py)

### Описание
Модуль `predicator.py` содержит функции для предсказания настроения сообщений.

### Классы и функции

1. **SomeModel**
   - Простая модель, предсказывающая случайное значение от 0.0 до 1.0.

2. **predict_message_mood(message, model, bad_thresholds=0.3, good_thresholds=0.8)**
   - Функция, предсказывающая настроение сообщения на основе модели.
   - Возвращает "неуд", "норм" или "отл" в зависимости от предсказания модели.

### Тестирование (test_predicator.py)
Модуль `test_predicator.py` содержит юнит-тесты для функции `predict_message_mood` в файле `predicator.py`.

# Папка 02: Парсер JSON и Декоратор для измерения времени выполнения функции

## Задача 1: Парсер JSON (02/json_parser_utils.py)

Модуль `json_parser_utils.py` предоставляет утилитарные функции для разбора JSON-данных и поиска ключевых слов в полях JSON.

### Описание
Этот модуль предназначен для обработки JSON-данных и поиска ключевых слов в определенных полях. Он предоставляет функцию `parse_json`, которая принимает JSON-строку, список обязательных полей, список ключевых слов и функцию обратного вызова для каждого найденного ключевого слова. Модуль также включает вспомогательную функцию `func`, предназначенную для обработки результатов поиска.

### Использование
```python
import json_parser_utils

# Пример использования
json_str = '{"key1": "Word1 word2", "key2": "word2 word3"}'
required_fields = ["key1", "key2"]
keywords = ["word2", "word3"]

def keyword_callback(required_field, keyword):
    print(f"Keyword found in '{required_field}': {keyword}")

json_parser_utils.parse_json(json_str, required_fields, keywords, keyword_callback)
```

## Задача 2: Декоратор измерения времени выполнения (02/time_measurement_decorators.py)

Модуль `time_measurement_decorators.py` предоставляет декоратор для измерения и отчета о среднем времени выполнения декорированной функции за несколько вызовов.

### Описание
Этот модуль предназначен для измерения среднего времени выполнения функции за несколько вызовов с использованием декоратора. Он включает функцию-декоратор `average_time_deco`, принимающую параметр `k` - количество последних вызовов для расчета среднего времени. Модуль также содержит пример использования декоратора с функцией `my_function`.

### Использование
```python
import time_measurement_decorators

# Пример использования
@time_measurement_decorators.average_time_deco(5)
def my_function(arg):
    res = arg + " White! You're goddamn right"
    time.sleep(1)
    return res

# Вызов декорированной функции
result = my_function("Walter")
print(result)
```

# Папка 03: Кастомный список для поэлементного сложения, вычитания, сравнения и кастомного строкового представления.

## Задача 1: CustomList

## Описание

Модуль определяет класс `CustomList`, являющийся пользовательским расширением встроенного класса `list` в Python. Этот класс предоставляет дополнительные возможности для поэлементного сложения, вычитания, сравнения и кастомного строкового представления.

```python
class CustomList(list):
    # Код класса
    ...
```

### Функциональность
Сложение (__add__): Реализует операцию сложения для экземпляров CustomList, позволяя складывать их друг с другом или с обычными списками. Результатом является новый кастомный список.

Сложение (справа) (__radd__): Реализует операцию сложения справа, позволяя складывать экземпляры CustomList с обычными списками.

Вычитание (__sub__): Реализует операцию вычитания для экземпляров CustomList, позволяя вычитать их друг из друга или из обычных списков. Результатом является новый кастомный список.

Вычитание (справа) (__rsub__): Реализует операцию вычитания справа, позволяя вычитать экземпляры CustomList из обычных списков.

Сравнение (__eq__, __ne__, __le__, __ge__, __gt__, __lt__): Реализуют операции сравнения, сравнивая суммы элементов экземпляров CustomList. Сравнение с обычными списками не предусмотрено.

Строковое представление (__str__): Переопределенный метод для красивого вывода элементов списка и их суммы.

Статический метод (sum_centr): Вычисляет сумму элементов двух списков.

Пример использования
```python
Copy code
custom_list1 = CustomList([5, 1, 3, 7])
custom_list2 = CustomList([1, 2, 7])

result = custom_list1 + custom_list2  # CustomList([6, 3, 10, 7])
print(result)
# Вывод: CustomList([6, 3, 10, 7]) сумма элементов = 26

custom_list3 = CustomList([1])
result2 = custom_list3 + [2, 5]  # CustomList([3, 5])
print(result2)
# Вывод: CustomList([3, 5]) сумма элементов = 8
```
### Замечание
Списки всегда считаются числовыми для проведения арифметических операций.

# Папка 04: Дескрипторы и метаклассы

## Задача 1: Метакласс, который в начале названий всех атрибутов и методов, кроме магических, добавляет префикс "custom_"

## Описание




## Задача 2: Дескрипторы с проверками типов и значений данных

## Описание




